%% (Part 1) process coarse map

%%
% *Filter, Integrate, Correct*

opts = struct(...
    'workingDirectory',{...
        'proc/7/1/mdx',...
        'proc/8/1/mdx',...
        'proc/8/2/mdx',...
        'proc/8/3/mdx',...
        'proc/9/1/mdx',...
        'proc/9/2/mdx',...
        'proc/10/1/mdx',...
        'proc/10/2/mdx',...
        'proc/10/3/mdx',...
        'proc/10/6/mdx',...
        'proc/10/7/mdx'},...
    'xdsDir','../xds/',...
    'fileNameTemplate',{...
        'data/lys_nitr_7_bkg_1_????.cbf',...
        'data/lys_nitr_8_bkg_1_????.cbf',...
        'data/lys_nitr_8_bkg_1_????.cbf',...
        'data/lys_nitr_8_bkg_1_????.cbf',...
        'data/lys_nitr_9_bkg_2_????.cbf',...
        'data/lys_nitr_9_bkg_2_????.cbf',...
        'data/lys_nitr_10_bkg_1_????.cbf',...
        'data/lys_nitr_10_bkg_1_????.cbf',...
        'data/lys_nitr_10_bkg_1_????.cbf',...
        'data/lys_nitr_10_bkg_1_????.cbf',...
        'data/lys_nitr_10_bkg_1_????.cbf'},...
    'frameRange',{...
        [1,50],...
        [171,220],...
        [126,175],...
        [1,50],...
        [1,50],...
        [46,95],...
        [251,300],...
        [296,345],...
        [1,360],...
        [71,120],...
        [116,165]},...
    'ndiv',[5,5,5],...  % this choice impacts speed to a large extent
    'window',2,...
    'maxCount',20,...
    'smax',Inf,...
    'binMode','coarse',...
    'minimumCounts',10,...
    'minimumPixels',10,...
    'parallel',true,...
    'binExcludedVoxels',true...  % treats excluded voxels as Bragg peaks
    );

% assign run options
for j=1:length(opts)
    opts(j).run = {'xds2geom','cbf2geom','filter','integrate','correct','export'};
end 

[tf,EM] = proc.Batch.autorun(opts);

clear opts

%%
% *combine, scale and merge*

[tf,EM] = proc.Batch.combine(...
    'workingDirectory','proc/mdx',...
    'exportIn',{...
        '../7/1/mdx/export.mat',...
        '../8/1/mdx/export.mat',...
        '../8/2/mdx/export.mat',...
        '../8/3/mdx/export.mat',...
        '../9/1/mdx/export.mat',...
        '../9/2/mdx/export.mat',...
        '../10/1/mdx/export.mat',...
        '../10/2/mdx/export.mat',...
        '../10/3/mdx/export.mat',...
        '../10/6/mdx/export.mat',...
        '../10/7/mdx/export.mat'},...
    'combineBragg',true,...
    'mergeNeighbors',true);

[tf,EM] = proc.Batch.scale(...
    'workingDirectory','proc/mdx',...
    'scaleIn','combine.mat',...
    'csMult',10,'cizMult',1); % relaxing regularization of c improved cc 1/2

% *merge Diffuse intensity*
[tf,EM] = proc.Batch.merge(...
    'workingDirectory','proc/mdx');

% *merge Bragg intensity*
[tf,EM] = proc.Batch.merge(...
    'workingDirectory','proc/mdx',...
    'matOut','mergeBragg.mat',...
    'logOut','mergeBragg.log',...
    'mergeBragg',true,...
    'sigmaCutoff',2); % be harsh with outliers!

%% (Part 2) Absolute intensity scaling

%%
% *replace Bragg intensities by those integrated with xds / aimless*

mergeBragg = load('proc/mdx/mergeBragg.mat','hklMerge');

S2R = proc.script.ScaleToReference(...
    'mtzIn','proc/aimless/XDS_ASCII_aimless.mtz',...
    'refcols',{'hasu'  'kasu'  'lasu'  'I'  'sigma'},...
    'outcols',{'hasu'  'kasu'  'lasu'  'I'  'sigma'},... % use same column names in output table
    'nIter',1E4); % maximum number of iterations for outlier rejection.

% load aimless and scale 2 bragg
[hklMerge,hklRef,scaleFactor] = S2R.run(mergeBragg.hklMerge);

save('proc/mdx/mergeBraggAimless.mat','hklMerge','hklRef','scaleFactor');

clear hklMerge hklRef scaleFactor S2R mergeBragg

%%
% *define unit cell contents*

load('proc/10/1/mdx/export.mat','AverageGeometry');

Crystal = AverageGeometry.Crystal;
Crystal.a_axis = [];
Crystal.b_axis = [];
Crystal.c_axis = [];

SpaceGroup = symm.SpaceGroup(Crystal.SpaceGroup.spaceGroupNumber);
asuPerUC = numel(SpaceGroup.generalPositions);
Vc = Crystal.UnitCell.vCell;

lys_sequence = [...
    'KVFGRCELAAAMKRHGLDNYRGYSLGNWVCAAKFESNFNTQATNRNTDGSTDYGILQINS',...
    'RWWCNDGRTPGSRNLCNIPCSALLSSDITASVNCAKKIVSDGNGMNAWVAWRNRCKGTDV',...
    'QAWIRGCRL'];
P = model.chem.Peptide(lys_sequence);
Lys = P.build();

HOH = model.chem.Water(); % hard-coded (could use HOH.cif instead...)

data_NO3 = io.mmcif.searchFile('proc/NO3.cif','NO3');
NO3 = io.mmcif.convert2Molecule(io.mmcif.parseRecord(data_NO3.record));

% *totals*

nHOH = 290*asuPerUC; % estimated
nNO3 = 6*asuPerUC;
nLys = 1*asuPerUC;

Molecules = [Lys,NO3,HOH];
occupancies = [nLys,nNO3,nHOH];

save('proc/mdx/unitCellInventory.mat',...
    'Molecules','occupancies','Crystal','Vc','asuPerUC');

clear Molecules occupancies nHOH nLys Lys HOH data_NO3 nNO3 NO3 P 
clear lys_sequence Crystal SpaceGroup asuPerUC 
clear Vc AverageGeometry

%%
% *scaling by modofied Krogh-Moe method*

[tf,EM] = proc.Batch.rescale(...
    'workingDirectory','proc/mdx/',...
    'unitCellInventoryIn','unitCellInventory.mat',...
    'mergeIn','merge.mat',... 
    'mergeBraggIn','mergeBraggAimless.mat',... 
    'mergeOut','mergeAbsolute.mat',... % bragg and diffuse together
    'scaleIn','scale.mat',...
    'scaleOut','scaleAbsolute.mat',...
    'matOut','rescale.mat',... % stats about scaling are saved here
    'logOut','rescale.log',...
    'smax',1,...
    'npts',501,...
    'scutoff',.7); % maximum 1/d to use in scaling
%%
% *copy scaling models over*

% get list of wedge scatterbrain directories from combine.mat
load('proc/mdx/combine.mat','options');
exportDir = cellfun(@fileparts,options.exportIn,'Uni',0);

% get scaling model
scale = load('proc/mdx/scaleAbsolute.mat');

% export scaling models
for j=1:length(exportDir)
    ScalingModel = scale.ScalingModel(j);
    save(fullfile('proc/mdx/',exportDir{j},'scale.mat'),'ScalingModel');
end

clear j ScalingModel scale exportDir options

%% (Part 3) Final map

%%
% *reintegrate on fine grid*

workingDirectories = {...
        'proc/7/1/mdx',...
        'proc/8/1/mdx',...
        'proc/8/2/mdx',...
        'proc/8/3/mdx',...
        'proc/9/1/mdx',...
        'proc/9/2/mdx',...
        'proc/10/1/mdx',...
        'proc/10/2/mdx',...
        'proc/10/3/mdx',...
        'proc/10/6/mdx',...
        'proc/10/7/mdx'};

opts = struct(...
    'workingDirectory',workingDirectories,...
    'matOut','grid.mat',...
    'smax',Inf,...
    'getSymmetryEquivalents',true,...
    'ndiv',[13,11,11],...
    'excludeBraggPosition',true); 

for j=1:length(opts)
    [tf,EM] = proc.Batch.grid(opts(j));
end
%%
% *Re-integrate using fine grids*

opts = struct(...
    'workingDirectory',workingDirectories,...
    'geometryIn','geom.mat',...
    'bkgGeometryIn','geomBkg.mat',...
    'gridIn','grid.mat',...
    'scaleIn','scale.mat',...
    'matOut','reintegrate.mat',...
    'logOut','reintegrate.log',...
    'minimumCounts',0,...
    'minimumPixels',10,...
    'parallel',true);

for j=1:length(opts)
    [tf,EM] = proc.Batch.reintegrate(opts(j));
end

% *merge the result*

% get crystal info
load proc/mdx/unitCellInventory.mat Crystal

M = proc.script.MergeScaledDiffuse(...
    'Grid',grid.Sub3d('ndiv',[13,11,11]),...
    'Crystal',Crystal,...
    'nMin',2,...
    'workingDirectory','proc/mdx');

files = {...
    '../7/1/mdx/reintegrate.mat',...
     '../8/1/mdx/reintegrate.mat',...
     '../8/2/mdx/reintegrate.mat',...
     '../8/3/mdx/reintegrate.mat',...
     '../9/1/mdx/reintegrate.mat',...
     '../9/2/mdx/reintegrate.mat',...
     '../10/1/mdx/reintegrate.mat',...
     '../10/2/mdx/reintegrate.mat',...
     '../10/3/mdx/reintegrate.mat',...
     '../10/6/mdx/reintegrate.mat',...
     '../10/7/mdx/reintegrate.mat'};

fn = M.mapToColumns(files);

[hklTable,isincl] = M.mergeColumns(fn);

% split and merge for calculating cc1/2, cc*
rng(0,'twister'); % for reproducibility
[hklTable2] = M.mergeRandomHalfSets(fn,isincl);

M.clearTmp(fn);

% save table to mat file
hklMerge = hklTable;
save('proc/mdx/mergeFine.mat','hklMerge');
clear hklMerge hklTable isincl M

hklMerge = hklTable2;
save('proc/mdx/mergeFineSplit.mat','hklMerge');

clear hklMerge hklTable2

